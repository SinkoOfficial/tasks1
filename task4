Практическое задание: Рефакторинг иерархии классов (Python)
Предыстория
Вы получили в наследство код системы управления сотрудниками в IT-компании. Код работает, но он крайне "хрупкий": иерархия слишком глубокая, классы перегружены логикой, а добавление нового типа сотрудника требует переписывания базовых методов.
Текущий "плохой" код (Anti-pattern)
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    def work(self):
        pass

    def get_report_format(self):
        # Метод God Class: знает о форматах всех отделов
        return f"Report for {self.name}: Data..."

class Developer(Employee):
    def work(self):
        return "Writing code"

class TeamLead(Developer):
    # Глубокое наследование: TeamLead вынужден быть Developer, 
    # даже если он уже не пишет код, а только управляет.
    def manage(self):
        return "Managing team"

class RobotSentinel(Employee):
    # Нарушение LSP: Роботу не нужна зарплата, но он наследует Employee
    def __init__(self, model):
        super().__init__(name=model, salary=0)

Задание
1. Рефакторинг: Extract Class и Композиция
Разделите класс Employee. Выделите логику формирования отчетов в отдельный класс или семейство классов (паттерн Strategy).
Создайте классы JSONReport, PDFReport, HTMLReport.
Сотрудник должен принимать объект отчета как аргумент (Композиция).
2. Рефакторинг: Наследование vs Композиция
Избавьтесь от жесткой связи TeamLead extends Developer.
Сделайте так, чтобы роли (Разработчик, Менеджер, Тестировщик) были отдельными объектами-поведениями, которые можно назначать сотруднику.
Подсказка: Используйте список roles внутри класса Employee.
3. Исправление нарушения LSP
Решите проблему с RobotSentinel.
Выделите общий интерфейс (или абстрактный базовый класс) Worker, который содержит только метод work().
Employee (с зарплатой) и Robot (без зарплаты) должны наследоваться от Worker.
Требования к реализации
Используйте модуль abc для создания абстрактных базовых классов.
Напишите небольшой скрипт, демонстрирующий работу вашей новой архитектуры:
Создание сотрудника.
Динамическое добавление ему роли "Manager".
Генерация отчета в формате JSON.
Добавьте комментарии, объясняющие, какой именно принцип рефакторинга был применен.
Контрольные вопросы
Почему использование списка ролей (композиция) лучше, чем создание класса ManagerDeveloper через множественное наследование?
Как ваша новая структура соответствует принципу Open/Closed (открыто для расширения, закрыто для изменения)?
