task 1:
Что нужно сделать после анализа:
Переписать функции, разделив ответственность.
Использовать константы вместо «магических чисел».
Добавить классы для пользователя, если это улучшает структуру.
Убрать дублирование кода.
Сделать код читаемым и поддерживаемым.

task 2:
Выберите любой тип программного продукта, который вы хотели бы разработать.
Укажите его название и краткое назначение (2–3 предложения).
Постройте полный жизненный цикл ПО, включив в него следующие этапы:
Формирование требований
Анализ и уточнение требований
Проектирование
Реализация (кодирование)
Тестирование
Внедрение
Эксплуатация и сопровождение
Вывод из эксплуатации (устаревание)
Для каждого этапа опишите, что именно происходит в рамках вашего выбранного проекта (2–3 предложения на этап).
Дополнительно постройте схему жизненного цикла:
можно в виде линейной схемы,
либо в виде блок-схемы,
либо в виде каскадной (Waterfall) модели.
Добавьте краткий вывод, почему выбранная модель жизненного цикла подходит для вашего продукта.

task 3.1:
Код читается
Каждый класс отвечает за одно
Можно менять UI без переписывания логики

task 3.2:
Новую оплату можно добавить без изменения старого кода
Код расширяемый и устойчивый

task 3.3:
Проект можно масштабировать
Код готов к командной работе

task 4:
1. Рефакторинг: Extract Class и Композиция
Разделите класс Employee. Выделите логику формирования отчетов в отдельный класс или семейство классов (паттерн Strategy).
Создайте классы JSONReport, PDFReport, HTMLReport.
Сотрудник должен принимать объект отчета как аргумент (Композиция).
2. Рефакторинг: Наследование vs Композиция
Избавьтесь от жесткой связи TeamLead extends Developer.
Сделайте так, чтобы роли (Разработчик, Менеджер, Тестировщик) были отдельными объектами-поведениями, которые можно назначать сотруднику.
Подсказка: Используйте список roles внутри класса Employee.
3. Исправление нарушения LSP
Решите проблему с RobotSentinel.
Выделите общий интерфейс (или абстрактный базовый класс) Worker, который содержит только метод work().
Employee (с зарплатой) и Robot (без зарплаты) должны наследоваться от Worker.
Требования к реализации
Используйте модуль abc для создания абстрактных базовых классов.
Напишите небольшой скрипт, демонстрирующий работу вашей новой архитектуры:
Создание сотрудника.
Динамическое добавление ему роли "Manager".
Генерация отчета в формате JSON.
Добавьте комментарии, объясняющие, какой именно принцип рефакторинга был применен.

task 5:
Задание 1. 
Условие:
Создай функцию sum_numbers(a, b), которая возвращает сумму двух чисел.
Создай функцию is_even(number), которая возвращает True, если число чётное, иначе False.
Вызови обе функции и выведи результат на экран.
Задание 2. 
Условие:
Дан код:
def f(x):
    return x * 2
Переименуй функцию так, чтобы было понятно, что она делает.
Добавь комментарий.
Проверь, что результат работы не изменился.
Подсказка: результат должен остаться тем же.
Задание 3. 
Условие:
Создай класс Car.
Добавь атрибут brand.
Создай метод get_brand(), который возвращает марку автомобиля.
Создай объект класса и вызови метод.
Важно: метод должен использовать self.
Задание 4. 
Условие:
Дана функция:
def calculate_area(width, height):
    return width * height
Создай класс Rectangle.
Перенеси логику функции в метод area().
Убедись, что результат вычислений не изменился.
Смысл задания: логика та же, структура кода лучше.

task6:
Задание 1— Упрощение условий
Код:
def is_adult(age):
    if age >= 18:
        return True
    else:
        return False
Требуется:
Упростить функцию
Поведение функции менять нельзя

Задание 2— Extract Method
Код:
def print_student_result(name, scores):
    total = 0
    for score in scores:
        total += score
    average = total / len(scores)
    print(name, "average score:", average)
Требуется:
Вынести подсчёт среднего балла в отдельную функцию
Сделать код более читаемым

Задание 3— Удаление дублирования
Код:
price1 = amount * 0.9
tax1 = price1 * 0.12

price2 = order * 0.9
tax2 = price2 * 0.12
Требуется:
Убрать дублирование
Использовать одну функцию

Задание 4— Магические числа
Код:
def calculate_salary(hours):
    return hours * 450
Требуется:
Убрать «магическое число»
Использовать константу



Задание 5— Single Responsibility
Код:
def process_user(user):
    print(user)
    save_to_db(user)
    send_email(user)
Требуется:
Разделить код на логические функции
Улучшить читаемость

 Задание 6— Рефакторинг условий
Код:
def get_discount(age, is_student):
    if age < 18:
        return 0.2
    else:
        if is_student:
            return 0.15
        else:
            return 0
Требуется:
Упростить структуру условий
Код должен стать короче и понятнее

Задание 7— Большая функция
Код:
def order_info(order):
    total = 0
    for item in order:
        total += item["price"]
    print("Total:", total)

    if total > 10000:
        print("Free delivery")
    else:
        print("Delivery cost: 1000")
Требуется:
Разделить на несколько функций
Убрать лишнюю логику из одной функции
Улучшить читаемость

task7:
1:
Примените технику Guard Clauses (граничные условия), чтобы избавиться от глубокой вложенности if.
Вынесите тарифы в отдельную структуру данных (словарь или константы).
Разбейте метод на несколько подфункций (например, расчет базовой стоимости и расчет надбавки за вес).
2:
Используйте паттерн Introduce Parameter Object. Сгруппируйте связанные данные (например, city, street, house в объект Address).
Примените именованные аргументы или dataclasses для хранения данных пользователя.
Разделите ответственность: метод должен либо создавать пользователя, либо отправлять уведомление (принцип Single Responsibility).
3:
Создайте базовый абстрактный класс BaseNotification и наследников для каждого типа связи.
Реализуйте рефакторинг Replace Conditional with Polymorphism.
Сделайте так, чтобы NotificationService принимал объект уведомления и вызывал его метод send(), не зная деталей реализации.

task8:
1:
Выбор программного средства:
Откройте любое приложение на компьютере (например, текстовый редактор, калькулятор, браузер или простую программу, которую вы написали сами).
Тестирование функциональности:
Определите 5–7 основных функций программы.
Для каждой функции выполните проверку на корректность:
Примеры действий: ввод данных, сохранение файла, расчет результата, открытие/закрытие программы.
Зафиксируйте результаты в таблице:
| Функция | Ожидаемый результат | Фактический результат | Ошибка (да/нет) |
Тестирование надежности:
Проверьте, как программа ведет себя при нестандартных действиях:
Ввод некорректных данных (например, буквы вместо чисел).
Одновременное открытие нескольких файлов.
Прерывание программы в процессе работы.
Зафиксируйте наблюдения и предложите меры для предотвращения сбоев.
Документирование:
Сделайте скриншоты тестов и ошибок.
Составьте краткий отчет:
Какие функции работают корректно.
Где обнаружены ошибки.
Какие меры можно предпринять для повышения надежности ПО.
2:
Создание или выбор программы:
Напишите простую программу на любом языке (например, калькулятор на Python, программа для учета данных в Excel, или макрос).
Либо используйте уже существующее небольшое приложение на компьютере.
Функциональное тестирование:
Определите основные функции программы (например: сложение/вычитание, добавление данных, сохранение файла).
Проверьте каждую функцию с разными типами данных: корректными и некорректными.
Зафиксируйте результаты в таблице:
| Функция | Тестовые данные | Ожидаемый результат | Фактический результат | Ошибка (да/нет) |
Тестирование надежности:
Проверьте поведение программы при:
Неправильном вводе данных.
Попытке выполнить запрещённые действия (например, деление на ноль, удаление файла, который открыт).
Многократном быстром нажатии кнопок или открытии нескольких окон.
Зафиксируйте сбои и предложите исправления.
Исправление ошибок:
Попробуйте исправить хотя бы одну найденную ошибку в программе.
Повторите тестирование после исправления, чтобы убедиться, что функция теперь работает корректно.
Отчёт:
Составьте короткий отчёт с результатами тестирования, найденными ошибками и принятыми мерами для повышения надежности программы.
Сделайте скриншоты тестов и исправленных ошибок.

task9:
Определиться с темой.
Это должен быть маленький сервис (набор микросервисов) на любом языке и с использованием любых технологий, который будет принимать запрос, проводить какую-то работу и возвращать ответ. Список возможных вариантов (чтобы определить направление для идей) есть в конце этого документа.
Подготовить git-репозиторий. Можно использовать любую систему -- Github, Bitbucket, Gitlab, Gitea, CodeCommit.
В рамках подготовки репозитория нужно сделать один initial коммит (README.md, .gitignore, LICENSE) и после этого подготовить репозитория для работы по выбранному подходу:
Для TBD запретить прямые коммиты в ветку main
Для git-flow от main создать develop ветку, и запретить прямые коммиты в обе ветки. Это ограничение сильно упростит жизнь в будущем. Не все системы работы с git позволяют установить эти ограничения, по крайней мере на бесплатном тарифе.
На этом же шаге опционально можно повесить хуки с проверкой линтерами, если выбранный язык разработки это позволяет.
Подготовить .gitconfig в своём локальном окружении.
Установить имя, e-mail и привязать граватар к e-mail.
Провести декомпозицию задачи.
По итогу, должно быть не менее 5 функциональных требований (пользовательских историй). Их нужно опубликовать в любой системе управления задачами (т.е. можно испозовать issues в GitHub, можно Trello, можно GoogleDoc).
Сделать отчет в ворде 

task10:
Общие требования
1. Строго после сдачи 1-й работы (я закрыл issue без вопросов) приступить к выполнению issues из своего проекта, следуя выбранному методу управления ветками.
2. Задачи необходимо линковать с issues. Если в процессе работы возникнет необходимость создать дополнительную issue под фичу или баг -- можно смело это сделать.
3. После завершения работы, подготовить релиз (в случае `git-flow`, это `release/` ветка и коммит в `master`). Протегать свой релиз (в случае GitHub, справа есть колонка, где можно указать тег решиза и написать `release notes`). В процессе подготовки релиза, обновить `README.md` файл, он должен содержать информацию о проекте, инструкцию по его сборке и запуску и пару примеров работы.

## На что я буду обращать внимание

1. Нарушение методов управления ветками (к примеру, прямые коммиты в `master` или `develop` ветки при работе по git-flow).
2. Нарушение хороших практик работы с git (если не настроен `.gitconfig` в системе, и коммиты идут от неизвестного пользователя).
3. Коммиты не слинкованы с issues, либо один коммит имеет решения для задачи выходящий за скоуп одной issue (коммит должен решать только ту задачу, которая поставлена в issue).
4. Наличие мусора в репозитории (бинарники, служебные файлы используемой IDE) -- всё это должно быть прикрыто `.gitignode`. Однако Gradle Wrapper в репо допускается.
5. Плохое (не полное, непонятное) описание сообщений к коммитам.

task11:
1. Сделать suit с тестами своего проекта (высокое покрытие не требуется, достаточно 2-3 use-кейса).
2. Реализовать тестовый пайплайн (в любой CI системе, к примеру GitHub Actions) на 2-3 операционных системах.
  Тригеры:
   - PR в `master` (и `develop`, в случае git-flow);
   - Мердж в `master` (и `develop`, в случае git-flow);
   - ручной запуск.
3. Добавить в `README.md` бейджик с результатами тестирования последнего мерджа в `master` (и `develop`, в случае git-flow).
же требования что были раньше, просто проверять буду значительно строже).

task12:
Все изменения в проекте:
только через issue
только через Pull Request
Каждая issue:
имеет чёткое описание
имеет критерии готовности
Каждая ветка:
создаётся от develop или main (в зависимости от подхода)
связана с одной issue
Требования:
минимум 5 issues
минимум 5 PR
минимум 1 PR с правками после code review
